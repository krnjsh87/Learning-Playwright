# Day 21: Advanced Integration Testing & Mock Server Architecture

**Date:** Day 21 of 25  
**Duration:** 8 hours  
**Difficulty:** Advanced  
**Focus Area:** Service Mocking, Contract Testing, Advanced Integration Testing, Multi-Service Coordination, Load Testing Fundamentals, End-to-End Automation Patterns

---

## ðŸŽ¯ **Learning Objectives**

By the end of Day 21, you will:

âœ… Master advanced integration testing patterns  
âœ… Design and implement mock servers for complex scenarios  
âœ… Implement contract testing between services  
âœ… Create sophisticated API mocking strategies  
âœ… Test multi-service interactions effectively  
âœ… Handle asynchronous and event-driven testing  
âœ… Implement distributed tracing for test debugging  
âœ… Design load testing strategies for automation frameworks  
âœ… Create comprehensive end-to-end automation suites  
âœ… Build production-ready test infrastructure  

---

## â° **Daily Schedule (8 Hours)**

| Time | Activity | Duration |
|------|----------|----------|
| 8:00 - 8:30 | Review Day 20 & Integration Testing Introduction | 30 min |
| 8:30 - 10:30 | **Theory Session 1:** Advanced Service Mocking & Architecture | 2 hours |
| 10:30 - 11:00 | Break | 30 min |
| 11:00 - 1:00 PM | **Hands-On Lab 1:** Mock Server Implementation | 2 hours |
| 1:00 - 2:00 PM | Lunch break | 1 hour |
| 2:00 - 4:00 PM | **Theory Session 2:** Contract Testing & API Pacts | 2 hours |
| 4:00 - 4:30 PM | Break | 30 min |
| 4:30 - 6:30 PM | **Hands-On Lab 2:** Comprehensive Integration Test Suite | 2 hours |

---

## ðŸ“š **THEORY SESSION 1: Advanced Service Mocking & Architecture (2 hours)**

### **Part 21.1: Integration Testing Pyramid**

#### **The Testing Pyramid Concept**

```
                    /\
                   /E2E\
                  /Tests\
                 /________\
                 
                /\        /\
               /API\      /UI\
              /Tests\____/Tests\
             /________________\
             
            /\        /\        /\
           /Unit\    /Unit\    /Unit\
          /Tests\____/Tests\____/Tests\
         /___________________________\
         
Traditional Pyramid (bottom-up):
- Unit Tests (70%): Fast, isolated, many
- Integration Tests (20%): Medium speed, some services
- E2E Tests (10%): Slow, full stack, few

Problems with this approach:
- Too many unit tests don't catch real bugs
- Integration tests often flaky
- E2E tests slow down feedback loop
```

#### **Modern Testing Pyramid for Microservices**

```
Modern Approach:
- Contract Tests: Verify service boundaries
- Integration Tests: Test service interactions  
- Component Tests: Test components in isolation
- E2E Tests: Critical user journeys only

Better Balance:
- More contract tests (fast, reliable)
- Fewer E2E tests (slow, but crucial)
- Mocked dependencies (speed & reliability)
```

### **Part 21.2: Mock Server Architecture**

#### **Types of Mocking Strategies**

**1. In-Process Mocking (Embedded)**
```
Test Code â†’ Mocked Service (same process)

Advantages:
- Fastest execution
- Full control
- Easy debugging

Disadvantages:
- Can't test real network issues
- Language-specific
- Test environment differs from production

Example: cy.intercept(), sinon mocks
```

**2. Standalone Mock Server**
```
Test Code â†’ Network â†’ Mock Server

Advantages:
- More realistic network simulation
- Can test cross-process issues
- Language-agnostic
- Can be shared across test suites

Disadvantages:
- Slower than in-process
- Network latency
- More complex setup

Example: Prism, Mockoon, Custom Node server
```

**3. Service Virtualization**
```
Test Code â†’ Network â†’ Virtual Service
           (intercepts real requests)

Advantages:
- Highly realistic
- Can record/replay traffic
- Perfect for load testing

Disadvantages:
- Complex setup
- Expensive tools
- Slow execution

Example: VCR, Betamax, Wiremock
```

#### **Mock Server Comparison**

| Aspect | In-Process | Standalone | Service Virt. |
|--------|-----------|-----------|---------------|
| **Speed** | Very Fast | Fast | Medium |
| **Realism** | Low | Medium | High |
| **Setup** | Easy | Medium | Complex |
| **Debugging** | Excellent | Good | Good |
| **Scalability** | Limited | Good | Excellent |
| **Cost** | Free | Free | Paid |
| **Use Case** | Unit + Component | Integration | E2E + Load |

### **Part 21.3: Building a Mock Server with Express.js**

#### **Basic Mock Server Structure**

```javascript
// mock-server/server.js
const express = require('express');
const cors = require('cors');
const morgan = require('morgan');
const bodyParser = require('body-parser');

const app = express();

// Middleware
app.use(cors());
app.use(morgan('combined'));
app.use(bodyParser.json());

// Request logging middleware
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.path}`);
  next();
});

// ========================
// Mock API Endpoints
// ========================

// GET /api/users - List users
app.get('/api/users', (req, res) => {
  const { page = 1, limit = 10 } = req.query;
  
  res.json({
    data: [
      { id: 1, name: 'John Doe', email: 'john@example.com' },
      { id: 2, name: 'Jane Smith', email: 'jane@example.com' }
    ],
    pagination: { page: parseInt(page), limit: parseInt(limit) }
  });
});

// GET /api/users/:id - Get specific user
app.get('/api/users/:id', (req, res) => {
  const { id } = req.params;
  
  if (id === '0') {
    return res.status(404).json({ error: 'User not found' });
  }
  
  res.json({
    id: parseInt(id),
    name: 'John Doe',
    email: 'john@example.com',
    role: 'admin'
  });
});

// POST /api/users - Create user
app.post('/api/users', (req, res) => {
  const { name, email } = req.body;
  
  // Validation
  if (!name || !email) {
    return res.status(400).json({
      error: 'Missing required fields',
      required: ['name', 'email']
    });
  }
  
  // Simulate email validation
  if (!email.includes('@')) {
    return res.status(400).json({ error: 'Invalid email format' });
  }
  
  res.status(201).json({
    id: 3,
    name,
    email,
    createdAt: new Date().toISOString()
  });
});

// PUT /api/users/:id - Update user
app.put('/api/users/:id', (req, res) => {
  const { id } = req.params;
  const { name, email } = req.body;
  
  if (id === '0') {
    return res.status(404).json({ error: 'User not found' });
  }
  
  res.json({
    id: parseInt(id),
    name: name || 'John Doe',
    email: email || 'john@example.com',
    updatedAt: new Date().toISOString()
  });
});

// DELETE /api/users/:id - Delete user
app.delete('/api/users/:id', (req, res) => {
  const { id } = req.params;
  
  if (id === '0') {
    return res.status(404).json({ error: 'User not found' });
  }
  
  res.status(204).send();
});

// ========================
// Advanced Mock Features
// ========================

// Simulate delays
app.get('/api/slow-endpoint', (req, res) => {
  setTimeout(() => {
    res.json({ message: 'Slow response after 2 seconds' });
  }, 2000);
});

// Simulate errors
app.get('/api/error-endpoint', (req, res) => {
  res.status(500).json({ error: 'Internal server error' });
});

// Simulate timeout
app.get('/api/timeout-endpoint', (req, res) => {
  // Never responds - client will timeout
});

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'healthy' });
});

// ========================
// Error Handling
// ========================

app.use((err, req, res, next) => {
  console.error('Error:', err);
  res.status(500).json({
    error: 'Internal server error',
    message: err.message
  });
});

app.use((req, res) => {
  res.status(404).json({ error: 'Endpoint not found' });
});

// Start server
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Mock server running on http://localhost:${PORT}`);
});

module.exports = app;
```

#### **Mock Server with State Management**

```javascript
// mock-server/stateful-server.js
const express = require('express');
const app = express();

app.use(express.json());

// In-memory database
const state = {
  users: [
    { id: 1, name: 'John', email: 'john@example.com', deleted: false },
    { id: 2, name: 'Jane', email: 'jane@example.com', deleted: false }
  ],
  nextId: 3,
  requestCount: 0
};

// Middleware to track requests
app.use((req, res, next) => {
  state.requestCount++;
  res.header('X-Request-Count', state.requestCount);
  next();
});

// GET all users
app.get('/api/users', (req, res) => {
  const activeUsers = state.users.filter(u => !u.deleted);
  res.json(activeUsers);
});

// POST create user
app.post('/api/users', (req, res) => {
  const { name, email } = req.body;
  
  const newUser = {
    id: state.nextId++,
    name,
    email,
    deleted: false
  };
  
  state.users.push(newUser);
  res.status(201).json(newUser);
});

// DELETE user (soft delete)
app.delete('/api/users/:id', (req, res) => {
  const user = state.users.find(u => u.id === parseInt(req.params.id));
  
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  
  user.deleted = true;
  res.status(204).send();
});

// Reset state (for testing)
app.post('/reset', (req, res) => {
  state.users = [
    { id: 1, name: 'John', email: 'john@example.com', deleted: false },
    { id: 2, name: 'Jane', email: 'jane@example.com', deleted: false }
  ];
  state.nextId = 3;
  state.requestCount = 0;
  res.json({ message: 'State reset' });
});

// Get state (for debugging)
app.get('/debug/state', (req, res) => {
  res.json(state);
});

module.exports = app;
```

### **Part 21.4: Advanced Mocking Patterns**

#### **Pattern 1: Request Matching & Dynamic Responses**

```javascript
// Advanced request matching
app.get('/api/users', (req, res) => {
  const { status, role, page } = req.query;
  
  let users = state.users;
  
  // Filter by status
  if (status === 'active') {
    users = users.filter(u => !u.deleted);
  }
  
  // Filter by role
  if (role) {
    users = users.filter(u => u.role === role);
  }
  
  // Paginate
  const pageNum = parseInt(page) || 1;
  const pageSize = 10;
  const start = (pageNum - 1) * pageSize;
  const end = start + pageSize;
  
  res.json({
    data: users.slice(start, end),
    total: users.length,
    page: pageNum,
    pageSize
  });
});
```

#### **Pattern 2: Conditional Response Generation**

```javascript
// Return different responses based on input
app.post('/api/validate', (req, res) => {
  const { email, age } = req.body;
  const errors = [];
  
  // Validate email
  if (!email || !email.includes('@')) {
    errors.push({ field: 'email', message: 'Invalid email' });
  }
  
  // Validate age
  if (age < 18) {
    errors.push({ field: 'age', message: 'Must be 18+' });
  }
  
  if (errors.length > 0) {
    return res.status(400).json({ errors });
  }
  
  res.json({ valid: true, message: 'All validations passed' });
});
```

#### **Pattern 3: Latency Simulation**

```javascript
// Simulate different response times
app.get('/api/data/:speed', (req, res) => {
  const { speed } = req.params;
  const delays = {
    'fast': 50,
    'normal': 500,
    'slow': 2000,
    'timeout': 30000
  };
  
  const delay = delays[speed] || 500;
  
  setTimeout(() => {
    res.json({ message: `Response after ${delay}ms` });
  }, delay);
});
```

#### **Pattern 4: Streaming & Chunked Responses**

```javascript
// Stream large data
app.get('/api/stream', (req, res) => {
  res.setHeader('Content-Type', 'application/json');
  res.write('[');
  
  let count = 0;
  const stream = setInterval(() => {
    if (count > 0) res.write(',');
    res.write(JSON.stringify({ id: count, value: Math.random() }));
    
    if (++count >= 100) {
      clearInterval(stream);
      res.write(']');
      res.end();
    }
  }, 10);
});
```

### **Part 21.5: Mock Server Configuration & Testing**

#### **Docker-Compose with Mock Server**

```yaml
# docker-compose.yml - with mock server
version: '3.8'

services:
  # Real API server
  api:
    build: ./api
    ports:
      - "8080:8080"
    environment:
      NODE_ENV: production
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 10s
      timeout: 5s
      retries: 3

  # Mock server for testing
  mock-server:
    build: ./mock-server
    ports:
      - "3001:3001"
    environment:
      NODE_ENV: test
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3001/health"]
      interval: 10s
      timeout: 5s
      retries: 3

  # Test runner with access to both
  test-runner:
    build: ./tests
    environment:
      API_URL: http://api:8080
      MOCK_SERVER_URL: http://mock-server:3001
    depends_on:
      api:
        condition: service_healthy
      mock-server:
        condition: service_healthy
    volumes:
      - ./tests:/app/tests
      - ./reports:/app/reports

networks:
  default:
    name: test-network
```

---

## ðŸ’» **HANDS-ON LAB 1: Mock Server Implementation (2 hours)**

### **Exercise 21.1: Build Complete Mock Server**

#### **Step 1: Project Setup**

```bash
mkdir mock-server-project && cd mock-server-project

# Create directory structure
mkdir -p {server,tests,config,data,docs}

# Initialize npm
npm init -y

# Install dependencies
npm install express cors morgan body-parser dotenv

# Dev dependencies
npm install --save-dev nodemon jest supertest
```

#### **Step 2: Create .env Configuration**

```env
# .env
NODE_ENV=development
PORT=3001
MOCK_DELAY=0
ENABLE_LOGGING=true
RESET_INTERVAL=3600000
```

#### **Step 3: Create Mock Server**

**server/index.js:**

```javascript
const express = require('express');
const cors = require('cors');
const morgan = require('morgan');
const bodyParser = require('body-parser');
require('dotenv').config();

const app = express();

// Middleware
app.use(cors());
app.use(morgan('dev'));
app.use(bodyParser.json());

// State
const state = {
  users: [],
  products: [],
  orders: [],
  requestLog: []
};

// Initialize data
function initializeData() {
  state.users = [
    { id: 1, name: 'John Doe', email: 'john@example.com', role: 'admin' },
    { id: 2, name: 'Jane Smith', email: 'jane@example.com', role: 'user' }
  ];
  
  state.products = [
    { id: 1, name: 'Laptop', price: 999, stock: 10 },
    { id: 2, name: 'Mouse', price: 29, stock: 100 }
  ];
  
  state.orders = [
    { id: 1, userId: 1, items: [{ productId: 1, qty: 1 }], total: 999 }
  ];
}

initializeData();

// Middleware to simulate delays
app.use((req, res, next) => {
  const delay = parseInt(process.env.MOCK_DELAY) || 0;
  setTimeout(next, delay);
});

// ========================
// USER ENDPOINTS
// ========================

// GET /api/users
app.get('/api/users', (req, res) => {
  const { role } = req.query;
  
  let users = state.users;
  if (role) {
    users = users.filter(u => u.role === role);
  }
  
  res.json({ users, total: users.length });
});

// GET /api/users/:id
app.get('/api/users/:id', (req, res) => {
  const user = state.users.find(u => u.id === parseInt(req.params.id));
  
  if (!user) {
    return res.status(404).json({ error: 'User not found' });
  }
  
  res.json(user);
});

// POST /api/users
app.post('/api/users', (req, res) => {
  const { name, email, role } = req.body;
  
  // Validation
  if (!name || !email) {
    return res.status(400).json({ error: 'Name and email required' });
  }
  
  if (!email.includes('@')) {
    return res.status(400).json({ error: 'Invalid email format' });
  }
  
  const newUser = {
    id: Math.max(...state.users.map(u => u.id), 0) + 1,
    name,
    email,
    role: role || 'user'
  };
  
  state.users.push(newUser);
  res.status(201).json(newUser);
});

// ========================
// PRODUCT ENDPOINTS
// ========================

app.get('/api/products', (req, res) => {
  const { minPrice, maxPrice } = req.query;
  
  let products = state.products;
  
  if (minPrice) {
    products = products.filter(p => p.price >= parseInt(minPrice));
  }
  
  if (maxPrice) {
    products = products.filter(p => p.price <= parseInt(maxPrice));
  }
  
  res.json({ products, total: products.length });
});

app.get('/api/products/:id', (req, res) => {
  const product = state.products.find(p => p.id === parseInt(req.params.id));
  
  if (!product) {
    return res.status(404).json({ error: 'Product not found' });
  }
  
  res.json(product);
});

// ========================
// ORDER ENDPOINTS
// ========================

app.post('/api/orders', (req, res) => {
  const { userId, items } = req.body;
  
  if (!userId || !items || items.length === 0) {
    return res.status(400).json({ error: 'Invalid order' });
  }
  
  // Calculate total
  let total = 0;
  for (const item of items) {
    const product = state.products.find(p => p.id === item.productId);
    if (!product) {
      return res.status(404).json({ error: `Product ${item.productId} not found` });
    }
    if (product.stock < item.qty) {
      return res.status(409).json({ error: `Not enough stock for ${product.name}` });
    }
    total += product.price * item.qty;
    product.stock -= item.qty;
  }
  
  const newOrder = {
    id: Math.max(...state.orders.map(o => o.id), 0) + 1,
    userId,
    items,
    total,
    createdAt: new Date().toISOString()
  };
  
  state.orders.push(newOrder);
  res.status(201).json(newOrder);
});

// ========================
// ADMIN ENDPOINTS
// ========================

// Reset state
app.post('/admin/reset', (req, res) => {
  initializeData();
  res.json({ message: 'State reset' });
});

// Get current state
app.get('/admin/state', (req, res) => {
  res.json(state);
});

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'healthy' });
});

// ========================
// ERROR HANDLING
// ========================

app.use((req, res) => {
  res.status(404).json({ error: 'Endpoint not found' });
});

app.use((err, req, res, next) => {
  console.error('Error:', err);
  res.status(500).json({ error: 'Internal server error' });
});

// Start server
const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`Mock server listening on port ${PORT}`);
  console.log(`API: http://localhost:${PORT}/api`);
  console.log(`Admin: http://localhost:${PORT}/admin`);
});

module.exports = app;
```

#### **Step 3: Create Tests for Mock Server**

**tests/mock-server.test.js:**

```javascript
const request = require('supertest');
const app = require('../server/index');

describe('Mock Server Tests', () => {
  
  beforeEach(async () => {
    // Reset server state
    await request(app).post('/admin/reset');
  });

  describe('User Endpoints', () => {
    
    test('GET /api/users returns all users', async () => {
      const response = await request(app)
        .get('/api/users')
        .expect(200);
      
      expect(response.body.users).toHaveLength(2);
      expect(response.body.total).toBe(2);
    });

    test('GET /api/users/:id returns specific user', async () => {
      const response = await request(app)
        .get('/api/users/1')
        .expect(200);
      
      expect(response.body.name).toBe('John Doe');
      expect(response.body.email).toBe('john@example.com');
    });

    test('GET /api/users/:id returns 404 for non-existent user', async () => {
      await request(app)
        .get('/api/users/999')
        .expect(404);
    });

    test('POST /api/users creates new user', async () => {
      const response = await request(app)
        .post('/api/users')
        .send({
          name: 'Alice Brown',
          email: 'alice@example.com',
          role: 'admin'
        })
        .expect(201);
      
      expect(response.body.name).toBe('Alice Brown');
      expect(response.body.role).toBe('admin');
    });

    test('POST /api/users returns 400 for invalid email', async () => {
      const response = await request(app)
        .post('/api/users')
        .send({
          name: 'Test User',
          email: 'invalid-email'
        })
        .expect(400);
      
      expect(response.body.error).toContain('Invalid email');
    });

    test('GET /api/users filters by role', async () => {
      const response = await request(app)
        .get('/api/users?role=admin')
        .expect(200);
      
      expect(response.body.users).toHaveLength(1);
      expect(response.body.users[0].role).toBe('admin');
    });
  });

  describe('Product Endpoints', () => {
    
    test('GET /api/products returns all products', async () => {
      const response = await request(app)
        .get('/api/products')
        .expect(200);
      
      expect(response.body.products.length).toBeGreaterThan(0);
    });

    test('GET /api/products filters by price range', async () => {
      const response = await request(app)
        .get('/api/products?minPrice=50&maxPrice=1000')
        .expect(200);
      
      response.body.products.forEach(p => {
        expect(p.price).toBeGreaterThanOrEqual(50);
        expect(p.price).toBeLessThanOrEqual(1000);
      });
    });
  });

  describe('Order Endpoints', () => {
    
    test('POST /api/orders creates order', async () => {
      const response = await request(app)
        .post('/api/orders')
        .send({
          userId: 1,
          items: [{ productId: 2, qty: 5 }]
        })
        .expect(201);
      
      expect(response.body.userId).toBe(1);
      expect(response.body.total).toBe(145); // 29 * 5
    });

    test('POST /api/orders returns 409 when stock insufficient', async () => {
      const response = await request(app)
        .post('/api/orders')
        .send({
          userId: 1,
          items: [{ productId: 1, qty: 100 }]
        })
        .expect(409);
      
      expect(response.body.error).toContain('Not enough stock');
    });
  });

  describe('Admin Endpoints', () => {
    
    test('POST /admin/reset resets state', async () => {
      // Create user
      await request(app)
        .post('/api/users')
        .send({ name: 'Test', email: 'test@example.com' });
      
      // Verify user exists
      let response = await request(app).get('/api/users');
      expect(response.body.total).toBe(3);
      
      // Reset
      await request(app).post('/admin/reset').expect(200);
      
      // Verify state reset
      response = await request(app).get('/api/users');
      expect(response.body.total).toBe(2);
    });

    test('GET /admin/state returns current state', async () => {
      const response = await request(app)
        .get('/admin/state')
        .expect(200);
      
      expect(response.body).toHaveProperty('users');
      expect(response.body).toHaveProperty('products');
      expect(response.body).toHaveProperty('orders');
    });
  });

  describe('Health Check', () => {
    
    test('GET /health returns healthy status', async () => {
      const response = await request(app)
        .get('/health')
        .expect(200);
      
      expect(response.body.status).toBe('healthy');
    });
  });
});
```

#### **Step 4: Run Tests**

```bash
# Update package.json
{
  "scripts": {
    "start": "node server/index.js",
    "dev": "nodemon server/index.js",
    "test": "jest --coverage",
    "test:watch": "jest --watch"
  }
}

# Run tests
npm test

# Start server
npm start

# Development with auto-reload
npm run dev
```

### **Exercise 21.2: Integrate Mock Server with Cypress**

**cypress/e2e/with-mock-server.cy.js:**

```javascript
describe('Testing with Mock Server', () => {
  
  beforeEach(() => {
    // Reset mock server before each test
    cy.request('POST', 'http://localhost:3001/admin/reset');
    
    // Visit application
    cy.visit('http://localhost:3000', {
      onBeforeLoad: (win) => {
        // Redirect API calls to mock server
        win.fetch = function(url, options) {
          if (url.startsWith('/api')) {
            url = url.replace('/api', 'http://localhost:3001/api');
          }
          return originalFetch.apply(this, arguments);
        };
      }
    });
  });

  it('should display users from mock server', () => {
    cy.get('[data-testid="user-list"]').within(() => {
      cy.get('[data-testid="user-item"]').should('have.length', 2);
      cy.contains('John Doe').should('be.visible');
      cy.contains('Jane Smith').should('be.visible');
    });
  });

  it('should create new user and verify in mock server', () => {
    // Create user via UI
    cy.get('[data-testid="create-user-btn"]').click();
    cy.get('[data-testid="name-input"]').type('Alice Brown');
    cy.get('[data-testid="email-input"]').type('alice@example.com');
    cy.get('[data-testid="submit-btn"]').click();

    // Verify in mock server
    cy.request('GET', 'http://localhost:3001/api/users').then((response) => {
      expect(response.body.users).toHaveLength(3);
      expect(response.body.users[2].name).to.equal('Alice Brown');
    });
  });

  it('should handle validation errors from mock server', () => {
    cy.get('[data-testid="create-user-btn"]').click();
    cy.get('[data-testid="email-input"]').type('invalid-email');
    cy.get('[data-testid="submit-btn"]').click();

    // Verify error message displayed
    cy.get('[data-testid="error-message"]')
      .should('be.visible')
      .should('contain', 'Invalid email');
  });
});
```

---

## ðŸ“š **THEORY SESSION 2: Contract Testing & API Pacts (2 hours)**

### **Part 21.6: Introduction to Contract Testing**

#### **What is Contract Testing?**

Contract testing verifies that two services can work together based on an agreed-upon contract (API specification).

**Traditional Integration Testing Problem:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         Network        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Consumer   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ â”‚  Provider   â”‚
â”‚  (Frontend) â”‚                         â”‚  (Backend)  â”‚
â”‚             â”‚ â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ â”‚             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Problems:
- Must test with real provider running
- Slow test execution
- Flaky tests (network issues)
- Test data management complex
- Difficult to test error scenarios
- Provider changes break consumer tests
```

**Contract Testing Solution:**

```
Consumer Tests               Provider Tests
  â†“                             â†“
Mock Provider â†â† Pact â†â† Provider
  â†“                             â†“
Verify Contract        Verify Contract
```

#### **Contract Testing Benefits**

| Aspect | Traditional | Contract Testing |
|--------|-------------|------------------|
| **Speed** | Slow (real services) | Fast (mocked) |
| **Reliability** | Flaky | Deterministic |
| **Error Testing** | Hard | Easy |
| **Deployment Risk** | High | Low |
| **Feedback** | Slow | Instant |
| **Parallelization** | Limited | Excellent |
| **Cost** | High | Low |

### **Part 21.7: Pact - Consumer-Driven Contracts**

#### **Pact Concept**

Pact is a Consumer-Driven Contract (CDC) testing tool that helps coordinate between consumer and provider services.

**How Pact Works:**

1. **Consumer Test Phase:**
   - Consumer test defines what it expects from provider
   - Mock provider returns expected responses
   - Pact records all interactions as a "contract" file

2. **Contract File (JSON):**
   ```json
   {
     "interactions": [
       {
         "request": {
           "method": "GET",
           "path": "/api/users/1"
         },
         "response": {
           "status": 200,
           "body": { "id": 1, "name": "John" }
         }
       }
     ]
   }
   ```

3. **Provider Test Phase:**
   - Provider runs Pact against contract file
   - Provider verifies it can fulfill contract
   - Provider tests pass = contract satisfied

4. **Deployment Confidence:**
   - Both consumer and provider tested independently
   - If both pass, safe to deploy
   - Breaks are caught early

#### **Pact Consumer Setup (JavaScript)**

```bash
npm install --save-dev @pact-foundation/pact
```

**tests/pact/user-service.pact.js:**

```javascript
const { PactV3 } = require('@pact-foundation/pact');
const axios = require('axios');

const pact = new PactV3({
  consumer: 'UserConsumer',
  provider: 'UserService',
  logLevel: 'info'
});

describe('User Service Pact', () => {
  
  describe('GET /api/users/:id', () => {
    
    it('returns user data', async () => {
      await pact
        .addInteraction({
          states: [{ description: 'user exists' }],
          uponReceiving: 'a request for user 1',
          withRequest: {
            method: 'GET',
            path: '/api/users/1',
            headers: {
              Accept: 'application/json'
            }
          },
          willRespondWith: {
            status: 200,
            headers: {
              'Content-Type': 'application/json'
            },
            body: {
              id: 1,
              name: 'John Doe',
              email: 'john@example.com'
            }
          }
        })
        .executeTest(async (mockProvider) => {
          // Consumer code
          const response = await axios.get(
            `${mockProvider.url}/api/users/1`
          );
          
          expect(response.status).toBe(200);
          expect(response.data.name).toBe('John Doe');
        });
    });

    it('returns 404 when user does not exist', async () => {
      await pact
        .addInteraction({
          states: [{ description: 'user does not exist' }],
          uponReceiving: 'a request for non-existent user',
          withRequest: {
            method: 'GET',
            path: '/api/users/999'
          },
          willRespondWith: {
            status: 404,
            body: { error: 'User not found' }
          }
        })
        .executeTest(async (mockProvider) => {
          try {
            await axios.get(`${mockProvider.url}/api/users/999`);
          } catch (error) {
            expect(error.response.status).toBe(404);
          }
        });
    });
  });

  describe('POST /api/users', () => {
    
    it('creates new user', async () => {
      await pact
        .addInteraction({
          uponReceiving: 'a request to create user',
          withRequest: {
            method: 'POST',
            path: '/api/users',
            headers: { 'Content-Type': 'application/json' },
            body: {
              name: 'Alice',
              email: 'alice@example.com'
            }
          },
          willRespondWith: {
            status: 201,
            body: {
              id: 3,
              name: 'Alice',
              email: 'alice@example.com'
            }
          }
        })
        .executeTest(async (mockProvider) => {
          const response = await axios.post(
            `${mockProvider.url}/api/users`,
            { name: 'Alice', email: 'alice@example.com' }
          );
          
          expect(response.status).toBe(201);
          expect(response.data.id).toBeDefined();
        });
    });
  });
});
```

### **Part 21.8: Advanced Integration Patterns**

#### **Pattern: Event-Driven Testing**

```javascript
// Testing async/event-based interactions
describe('Event-Driven Integration', () => {
  
  it('should process order event asynchronously', async () => {
    // Set up event listener on mock server
    let orderProcessed = false;
    const eventListener = (event) => {
      if (event.type === 'ORDER_PROCESSED') {
        orderProcessed = true;
      }
    };

    // Publish order creation event
    cy.request('POST', '/api/orders', {
      userId: 1,
      items: [{ productId: 1, qty: 1 }]
    }).then((response) => {
      expect(response.status).toBe(201);
      
      // Wait for event processing
      cy.wait(1000);
      
      // Verify event was processed
      cy.request('GET', '/admin/events').then((eventResponse) => {
        const processedEvent = eventResponse.body.find(
          e => e.type === 'ORDER_PROCESSED' && e.orderId === response.body.id
        );
        expect(processedEvent).toBeDefined();
      });
    });
  });
});
```

#### **Pattern: Saga Testing**

```javascript
// Test distributed transactions (Sagas)
describe('Order Saga', () => {
  
  it('should complete full order saga', async () => {
    // Step 1: Reserve inventory
    cy.request('POST', '/api/inventory/reserve', {
      productId: 1,
      quantity: 1
    }).then((reserveResponse) => {
      expect(reserveResponse.status).toBe(200);
      
      // Step 2: Process payment
      cy.request('POST', '/api/payments', {
        amount: 999,
        cardToken: 'tok_visa'
      }).then((paymentResponse) => {
        expect(paymentResponse.status).toBe(200);
        
        // Step 3: Create shipment
        cy.request('POST', '/api/shipments', {
          orderId: reserveResponse.body.orderId,
          address: '123 Main St'
        }).then((shipmentResponse) => {
          expect(shipmentResponse.status).toBe(201);
          
          // Verify saga completed
          cy.request('GET', '/api/orders/1').then((orderResponse) => {
            expect(orderResponse.body.status).toBe('shipped');
          });
        });
      });
    });
  });

  it('should compensate on payment failure', async () => {
    // Set up failure scenario
    cy.request('POST', '/admin/failureMode', {
      endpoint: '/api/payments',
      statusCode: 500
    });

    // Attempt order
    cy.request('POST', '/api/orders', {
      userId: 1,
      items: [{ productId: 1, qty: 1 }]
    }).then((response) => {
      expect(response.status).toBe(400);
      
      // Verify compensating transaction
      cy.request('GET', '/api/inventory/1').then((inventoryResponse) => {
        expect(inventoryResponse.body.reserved).toBe(0);
      });
    });
  });
});
```

---

## ðŸ’» **HANDS-ON LAB 2: Comprehensive Integration Test Suite (2 hours)**

### **Exercise 21.3: Build Multi-Service Integration Tests**

Create `tests/integration/multi-service.test.js`:

```javascript
const axios = require('axios');

const MOCK_SERVER = 'http://localhost:3001';
const APP_URL = 'http://localhost:3000';

describe('Multi-Service Integration Tests', () => {
  
  beforeAll(async () => {
    // Start services
    // Wait for services to be ready
    let retries = 10;
    while (retries > 0) {
      try {
        await axios.get(`${MOCK_SERVER}/health`);
        break;
      } catch (error) {
        retries--;
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
  });

  beforeEach(async () => {
    // Reset mock server state
    await axios.post(`${MOCK_SERVER}/admin/reset`);
  });

  describe('User Management Flow', () => {
    
    test('Complete user lifecycle', async () => {
      // Step 1: Get initial users
      let response = await axios.get(`${MOCK_SERVER}/api/users`);
      const initialCount = response.body.users.length;
      
      // Step 2: Create new user
      response = await axios.post(`${MOCK_SERVER}/api/users`, {
        name: 'Test User',
        email: 'test@example.com',
        role: 'user'
      });
      const userId = response.data.id;
      expect(response.status).toBe(201);
      
      // Step 3: Verify user was created
      response = await axios.get(`${MOCK_SERVER}/api/users/${userId}`);
      expect(response.data.name).toBe('Test User');
      expect(response.status).toBe(200);
      
      // Step 4: Query all users
      response = await axios.get(`${MOCK_SERVER}/api/users`);
      expect(response.body.users).toHaveLength(initialCount + 1);
    });

    test('Error handling in user creation', async () => {
      try {
        await axios.post(`${MOCK_SERVER}/api/users`, {
          name: 'Invalid User'
          // Missing email
        });
        fail('Should have thrown error');
      } catch (error) {
        expect(error.response.status).toBe(400);
        expect(error.response.data.error).toContain('required');
      }
    });
  });

  describe('Order Processing Flow', () => {
    
    test('Create order with inventory management', async () => {
      // Step 1: Check product stock
      let response = await axios.get(`${MOCK_SERVER}/api/products/1`);
      const initialStock = response.data.stock;
      
      // Step 2: Create order
      response = await axios.post(`${MOCK_SERVER}/api/orders`, {
        userId: 1,
        items: [{ productId: 1, qty: 2 }]
      });
      expect(response.status).toBe(201);
      const orderId = response.data.id;
      
      // Step 3: Verify stock was updated
      response = await axios.get(`${MOCK_SERVER}/api/products/1`);
      expect(response.data.stock).toBe(initialStock - 2);
    });

    test('Prevent overselling', async () => {
      try {
        await axios.post(`${MOCK_SERVER}/api/orders`, {
          userId: 1,
          items: [{ productId: 1, qty: 1000 }]
        });
        fail('Should have thrown error');
      } catch (error) {
        expect(error.response.status).toBe(409);
        expect(error.response.data.error).toContain('Not enough stock');
      }
    });
  });

  describe('Data Consistency', () => {
    
    test('Verify referential integrity', async () => {
      // Create order for non-existent user should fail
      try {
        await axios.post(`${MOCK_SERVER}/api/orders`, {
          userId: 999,
          items: [{ productId: 1, qty: 1 }]
        });
        // If we get here, check that order wasn't created
        const ordersResponse = await axios.get(`${MOCK_SERVER}/admin/state`);
        const invalidOrder = ordersResponse.data.orders.find(o => o.userId === 999);
        expect(invalidOrder).toBeUndefined();
      } catch (error) {
        // Expected to fail
        expect([400, 404]).toContain(error.response.status);
      }
    });

    test('Atomic transaction behavior', async () => {
      // Create order with multiple items
      const response = await axios.post(`${MOCK_SERVER}/api/orders`, {
        userId: 1,
        items: [
          { productId: 1, qty: 1 },
          { productId: 2, qty: 5 }
        ]
      });

      expect(response.status).toBe(201);
      expect(response.data.total).toBe(999 + (29 * 5)); // Product prices

      // Verify all items in order
      expect(response.data.items).toHaveLength(2);
    });
  });
});
```

### **Exercise 21.4: Integration Test with Cypress**

**cypress/e2e/full-integration.cy.js:**

```javascript
describe('Full Application Integration', () => {
  
  beforeEach(() => {
    // Reset mock server
    cy.request('POST', 'http://localhost:3001/admin/reset');
    
    // Visit application
    cy.visit('http://localhost:3000');
  });

  it('should complete end-to-end user journey', () => {
    // 1. View products
    cy.get('[data-testid="products-link"]').click();
    cy.get('[data-testid="product-item"]').should('have.length.greaterThan', 0);
    
    // 2. View product details
    cy.get('[data-testid="product-item"]').first().click();
    cy.get('[data-testid="product-detail"]').should('be.visible');
    cy.get('[data-testid="add-to-cart"]').click();
    
    // 3. View cart
    cy.get('[data-testid="cart-link"]').click();
    cy.get('[data-testid="cart-item"]').should('have.length', 1);
    
    // 4. Proceed to checkout
    cy.get('[data-testid="checkout-btn"]').click();
    
    // 5. Fill order details
    cy.get('[data-testid="email-input"]').type('user@example.com');
    cy.get('[data-testid="address-input"]').type('123 Main St');
    
    // 6. Confirm order
    cy.get('[data-testid="place-order"]').click();
    
    // 7. Verify order confirmation
    cy.get('[data-testid="order-confirmation"]').should('contain', 'Order placed');
    
    // 8. Verify in mock server
    cy.request('GET', 'http://localhost:3001/api/orders').then((response) => {
      expect(response.body.orders).toHaveLength(2); // 1 existing + 1 new
    });
  });
});
```

### **Exercise 21.5: Quiz - Advanced Integration Testing**

**Question 1:** What is the main benefit of contract testing?
- A) Tests run slower
- B) Verifies services can work together without running both
- C) Replaces all integration tests
- D) Requires complex setup
**Answer: B** - Contract testing enables independent testing

**Question 2:** What does a Pact file contain?
- A) Source code
- B) Configuration settings
- C) Interactions between consumer and provider
- D) Database schema
**Answer: C** - Pact files contain verified interactions

**Question 3:** What is a mock server used for?
- A) Replace production server
- B) Simulate API responses in tests
- C) Store test data
- D) Run performance tests
**Answer: B** - Mock servers simulate API behavior

**Question 4:** How do you reset state in a mock server?
- A) Restart the server
- B) Call a reset endpoint
- C) Delete database
- D) Clear browser cache
**Answer: B** - Reset endpoints manage state

**Question 5:** What is Consumer-Driven Contract testing?
- A) Consumer tests define contract, provider verifies it
- B) Provider defines contract, consumer implements
- C) Both agree on contract beforehand
- D) No contract needed
**Answer: A** - Consumer-driven contracts start from consumer needs

---

## ðŸ§ª **Mini-Project 21.1: E-Commerce Integration Test Suite**

### **Requirements**

Build a complete integration test suite for an e-commerce platform:

**Functional Flows:**
1. Product Catalog Management
2. Shopping Cart Operations
3. Order Processing
4. Inventory Management
5. Payment Integration
6. Shipping Coordination

**Test Scenarios:**
- Happy path (everything works)
- Error scenarios (invalid inputs, API failures)
- Edge cases (boundary values, race conditions)
- Data consistency checks
- Compensation/rollback scenarios

**Deliverables:**
1. Mock server with all endpoints
2. Comprehensive integration tests
3. Cypress E2E tests
4. Contract tests using Pact
5. Documentation
6. Docker Compose setup

### **Project Structure**

```
ecommerce-integration-tests/
â”œâ”€â”€ mock-server/
â”‚   â”œâ”€â”€ server.js
â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”œâ”€â”€ products.js
â”‚   â”‚   â”œâ”€â”€ users.js
â”‚   â”‚   â”œâ”€â”€ orders.js
â”‚   â”‚   â””â”€â”€ inventory.js
â”‚   â””â”€â”€ models/
â”‚       â””â”€â”€ state.js
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â”‚   â”œâ”€â”€ product-flow.test.js
â”‚   â”‚   â”œâ”€â”€ order-flow.test.js
â”‚   â”‚   â””â”€â”€ payment-flow.test.js
â”‚   â””â”€â”€ pact/
â”‚       â””â”€â”€ services.pact.js
â”œâ”€â”€ cypress/
â”‚   â”œâ”€â”€ e2e/
â”‚   â”‚   â”œâ”€â”€ shopping-flow.cy.js
â”‚   â”‚   â”œâ”€â”€ checkout.cy.js
â”‚   â”‚   â””â”€â”€ admin.cy.js
â”‚   â””â”€â”€ pages/
â”‚       â”œâ”€â”€ ProductPage.js
â”‚       â”œâ”€â”€ CartPage.js
â”‚       â””â”€â”€ CheckoutPage.js
â”œâ”€â”€ docker-compose.yml
â””â”€â”€ README.md
```

---

## ðŸ“Š **Day 21 Assessment**

### **Test Coverage Metrics**

- Unit test coverage: 80%+
- Integration test coverage: 70%+
- E2E critical flows: 100%
- Error scenarios: 80%+

### **Test Execution Criteria**

- All tests pass
- No flaky tests
- Performance: < 2 seconds per unit test
- Integration tests: < 5 seconds per scenario
- E2E tests: < 30 seconds per user flow

---

## ðŸ“‹ **Daily Checklist - Day 21**

- [ ] Reviewed Day 20 Docker fundamentals
- [ ] Understood integration testing pyramid
- [ ] Completed Theory Session 1
- [ ] Learned mock server architecture patterns
- [ ] Built basic mock server with Express
- [ ] Created mock server state management
- [ ] Completed Exercise 21.1
- [ ] Built comprehensive API mocking
- [ ] Completed Theory Session 2
- [ ] Learned contract testing principles
- [ ] Understood Pact framework basics
- [ ] Completed Exercise 21.2
- [ ] Created integration test suite
- [ ] Integrated mock server with Cypress
- [ ] Tested multi-service scenarios
- [ ] Completed all quiz questions (5/5)
- [ ] Built Mini-Project 21.1
- [ ] Documented test architecture
- [ ] Set up Docker environment
- [ ] Pushed code to GitHub

**Daily Metrics:**
- Quiz Score: ___/5
- Tests Created: ___ count
- Mock Endpoints: ___ count
- Integration Scenarios: ___ count
- E2E Flows Tested: ___ count
- Code Coverage: ____%
- Confidence Level (1-5): ___
- Time Spent: ___ hours

---

## ðŸŽ¯ **Key Takeaways**

1. **Mock servers enable fast, reliable integration testing**
2. **Contract testing bridges consumer-provider gap**
3. **State management in mocks is critical**
4. **Multiple mocking strategies serve different purposes**
5. **Stateful mocks enable realistic scenarios**
6. **Resettable state prevents test pollution**
7. **API matching enables flexible mocking**
8. **Pact ensures bilateral contract satisfaction**
9. **E2E tests with mocks are efficient & reliable**
10. **Comprehensive integration coverage prevents production issues**

---

## ðŸ”— **Resources for Further Learning**

- [Mock Server Best Practices](https://mswjs.io/docs/getting-started)
- [Pact Documentation](https://pact.foundation)
- [Contract Testing Guide](https://martinfowler.com/articles/consumerDrivenContracts.html)
- [Integration Testing Strategies](https://testingcup.com)
- [Cypress Network Testing](https://docs.cypress.io/guides/guides/network-requests)

---

## ðŸš€ **Ready for Day 22?**

By completing Day 21, you've mastered:
- âœ… Integration testing fundamentals
- âœ… Mock server architecture and patterns
- âœ… Stateful API mocking
- âœ… Contract testing principles
- âœ… Pact framework usage
- âœ… Multi-service integration testing
- âœ… Event-driven testing patterns
- âœ… Saga pattern testing
- âœ… Data consistency verification
- âœ… Production-ready test infrastructure

**Next (Day 22):** Performance Testing, Load Testing & Advanced Metrics
- Load testing frameworks (K6, Apache JMeter)
- Performance benchmarking
- Continuous load testing in CI/CD
- SLA monitoring
- Advanced metrics collection

---

## ðŸ“Š **Course Progress**

```
Week 1          Week 2          Week 3          Week 4          Week 5
Foundation      Mastery         API Testing     DevOps/Docker   Integration/Advanced
Days 1-5        Days 6-11       Days 12-15      Days 16-20      Days 21-25
âœ… 100%         âœ… 100%         âœ… 100%         âœ… 100%         ðŸ”œ Day 21
                                                                (4%)

Overall: 21/25 Days Complete (84%)
Remaining: 4 Days to Complete (Days 22-25)
```

---

**Congratulations on reaching Day 21!** ðŸŽ‰

You've successfully completed:
- âœ… Weeks 1-4 (Foundations, Frameworks, APIs, DevOps)
- ðŸ”œ Week 5 (Advanced Integration & Performance)

---

*Last Updated: December 13, 2025*  
*Day 21 Complete Guide v1.0*  
*Week 5 Day 2 - Advanced Integration Testing & Mock Servers*  
*Master-level Integration Test Architecture for Enterprise Automation*
